(window.webpackJsonp=window.webpackJsonp||[]).push([[25],{382:function(s,e,l){"use strict";l.r(e);var t=l(42),a=Object(t.a)({},(function(){var s=this,e=s.$createElement,l=s._self._c||e;return l("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[l("h1",{attrs:{id:"symbols"}},[l("a",{staticClass:"header-anchor",attrs:{href:"#symbols"}},[s._v("#")]),s._v(" Symbols")]),s._v(" "),l("p",[s._v("自ECMAScript 2015起，symbol成为了一种新的原生类型，就像number和string一样。\nsymbol类型的值是通过Symbol构造函数创建的。")]),s._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[s._v('let sym1 = Symbol();\nlet sym2 = Symbol("key"); // 可选的字符串key\n')])])]),l("p",[s._v("Symbols是不可改变且唯一的。")]),s._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[s._v('let sym2 = Symbol("key")\nlet sym3 = Symbol("key")\n\nsym2 === sym3 // false, symbols是唯一的\n')])])]),l("p",[s._v("像字符串一样，symbols也可以被用做对象属性的键。")]),s._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[s._v('let sym = Symbol()\n\nlet obj = {\n  [sym]: "value"\n}\n\nconsole.log(obj[sym]) // "value"\n')])])]),l("p",[s._v("Symbols也可以与计算出的属性名声明相结合来声明对象的属性和类成员。")]),s._v(" "),l("div",{staticClass:"language- extra-class"},[l("pre",{pre:!0,attrs:{class:"language-text"}},[l("code",[s._v('const getClassNameSymbol = Symbol()\n\nclass C {\n  [getClassNameSymbol](){\n    return "C"\n  }\n}\n\nlet c = new C()\nlet className = c[getClassNameSymbol]() // "C"\n')])])])])}),[],!1,null,null,null);e.default=a.exports}}]);