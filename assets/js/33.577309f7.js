(window.webpackJsonp=window.webpackJsonp||[]).push([[33],{390:function(e,n,a){"use strict";a.r(n);var t=a(42),s=Object(t.a)({},(function(){var e=this,n=e.$createElement,a=e._self._c||n;return a("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[a("h1",{attrs:{id:"接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口"}},[e._v("#")]),e._v(" 接口")]),e._v(" "),a("p",[e._v("在 TypeScript 中，我们使用接口（Interfaces）来定义对象的类型。")]),e._v(" "),a("h2",{attrs:{id:"什么是接口"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#什么是接口"}},[e._v("#")]),e._v(" 什么是接口")]),e._v(" "),a("p",[e._v("在面向对象语言中，接口（Interfaces）是一个很重要的概念，它是对行为的抽象，而具体如何行动需要由类（classes）去实现（implement）。\nTypeScript 中的接口是一个非常灵活的概念，除了可用于对类的一部分行为进行抽象以外，也常用于对「对象的形状（Shape）」进行描述。")]),e._v(" "),a("h2",{attrs:{id:"简单的例子"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#简单的例子"}},[e._v("#")]),e._v(" 简单的例子")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("interface Person {\n  name: string\n  age: number\n}\n\nlet tom: Person = {\n  name: 'Tom',\n  age: 25\n}\n")])])]),a("p",[e._v("上面的例子中，我们定义了一个接口 "),a("code",[e._v("Person")]),e._v("，接着定义了一个变量 "),a("code",[e._v("tom")]),e._v("，它的类型是 "),a("code",[e._v("Person")]),e._v("。这样，我们就约束了 "),a("code",[e._v("tom")]),e._v(" 的形状必须和接口 "),a("code",[e._v("Person")]),e._v(" 一致。\n接口一般首字母大写。有的编程语言中会建议接口的名称加上 I 前缀。\n定义的变量比接口少了一些属性是不允许的：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("interface Person {\n  name: string\n  age: number\n}\n\nlet tom: Person = {\n  name: 'Tom'\n}\n// Property 'age' is missing in type '{ name: string }' but required in type 'Person'.\n")])])]),a("p",[e._v("多一些属性也是不允许的：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("interface Person {\n  name: string\n  age: number\n}\n\nlet tom: Person = {\n  name: 'Tom',\n  age: 25,\n  gender: 'male'\n}\n\n// Type '{ name: string age: number gender: string }' is not assignable to type 'Person'.\n// Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.\n")])])]),a("p",[e._v("可见，* 赋值的时候，变量的形状必须和接口的形状保持一致。*")]),e._v(" "),a("h2",{attrs:{id:"可选属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#可选属性"}},[e._v("#")]),e._v(" 可选属性")]),e._v(" "),a("p",[e._v("有时我们希望不要完全匹配一个形状，那么可以用可选属性：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("interface Person {\n  name: string\n  age?: number\n}\n\nlet tom: Person = {\n  name: 'Tom'\n}\n")])])]),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("interface Person {\n  name: string\n  age?: number\n}\n\nlet tom: Person = {\n  name: 'Tom',\n  age: 25\n}\n")])])]),a("p",[e._v("可选属性的含义是该属性可以不存在。")]),e._v(" "),a("p",[e._v("这时仍然不允许添加未定义的属性：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("interface Person {\n  name: string\n  age?: number\n}\n\nlet tom: Person = {\n  name: 'Tom',\n  age: 25,\n  gender: 'male'\n}\n\n// Type '{ name: string age: number gender: string }' is not assignable to type 'Person'.\n// Object literal may only specify known properties, and 'gender' does not exist in type 'Person'.\n")])])]),a("h2",{attrs:{id:"任意属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#任意属性"}},[e._v("#")]),e._v(" 任意属性")]),e._v(" "),a("p",[e._v("有时候我们希望一个接口允许有任意的属性，可以使用如下方式：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("interface Person {\n  name: string\n  age?: number\n  [propName: string]: any\n}\n\nlet tom: Person = {\n  name: 'Tom',\n  gender: 'male'\n}\n")])])]),a("p",[e._v("使用 [propName: string] 定义了任意属性取 string 类型的值。\n需要注意的是，一旦定义了任意属性，"),a("strong",[e._v("那么确定属性和可选属性的类型都必须是它的类型的子集")]),e._v("：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("interface Person {\n  name: string\n  age?: number\n  [propName: string]: string\n}\n\nlet tom: Person = {\n  name: 'Tom',\n  age: 25,\n  gender: 'male'\n}\n\n// Property 'age' of type 'number | undefined' is not assignable to string index type 'string'.\n// Type '{ name: string age: number gender: string }' is not assignable to type 'Person'.\n// Property 'age' is incompatible with index signature.\n// Type 'number' is not assignable to type 'string'.\n")])])]),a("p",[e._v("上例中，任意属性的值允许是 string，但是可选属性 age 的值却是 number，number 不是 string 的子属性，所以报错了。")]),e._v(" "),a("p",[e._v("另外，在报错信息中可以看出，此时 "),a("code",[e._v("{ name: 'Tom', age: 25, gender: 'male' }")]),e._v(" 的类型被推断成了 { "),a("code",[e._v("[x: string]: string | number name: string age: number gender: string }")]),e._v("，这是联合类型和接口的结合。")]),e._v(" "),a("h2",{attrs:{id:"只读属性"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#只读属性"}},[e._v("#")]),e._v(" 只读属性")]),e._v(" "),a("p",[e._v("有时候我们希望对象中的一些字段只能在创建的时候被赋值，那么可以用 "),a("code",[e._v("readonly")]),e._v(" 定义只读属性：")]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("interface Person {\n  readonly id: number\n  name: string\n  age?: number\n  [propName: string]: any\n}\n\nlet tom: Person = {\n  id: 89757,\n  name: 'Tom',\n  gender: 'male'\n}\n\ntom.id = 9527\n// Cannot assign to 'id' because it is a read-only property.\n")])])]),a("p",[e._v("上例中，使用 "),a("code",[e._v("readonly")]),e._v(" 定义的属性 "),a("code",[e._v("id")]),e._v(" 初始化后，又被赋值了，所以报错了。")]),e._v(" "),a("p",[a("em",[a("strong",[e._v("注意，只读的约束存在于第一次给对象赋值的时候，而不是第一次给只读属性赋值的时候：")])])]),e._v(" "),a("div",{staticClass:"language- extra-class"},[a("pre",{pre:!0,attrs:{class:"language-text"}},[a("code",[e._v("interface Person {\n  readonly id: number\n  name: string\n  age?: number\n  [propName: string]: any\n}\n\nlet tom: Person = {\n  name: 'Tom',\n  gender: 'male'\n}\n\ntom.id = 89757\n// Property 'id' is missing in type '{ name: string gender: string }' but required in type 'Person'.\n// Cannot assign to 'id' because it is a read-only property.\n")])])]),a("p",[e._v("上例中，报错信息有两处，第一处是在对 tom 进行赋值的时候，没有给 id 赋值。\n第二处是在给 tom.id 赋值的时候，由于它是只读属性，所以报错了。")])])}),[],!1,null,null,null);n.default=s.exports}}]);