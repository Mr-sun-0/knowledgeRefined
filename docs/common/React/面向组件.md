### 面向组件

#### 组件基础

##### 1、react的组件分为3个部分：

- 属性props
- 状态state
- 生命周期

##### 2、组件当中的重要内容

- 构建方式
- 组件的属性
- 生命周期

##### 3、tips

```js
//react的组件 是一个非常重要的概念  通过组件可以把页面中的ui部分切分成独立 高复用性的部件 让每个开发者更加专注于一个个的部件

// 组件和组件化
// 组件   就是用来实现页面局部功能的代码集合  简化页面的复杂程度 提高运行效率
// 组件化  当前程序都是使用组件完成的 那么这就是一个组件化的应用
```

##### 4、组件的创建

```js
####  1、函数组件/无状态组件
  function MyCom(){
      //这里组件名首字母必须大写，采用大驼峰命名法，小写字母是元素
      return(
          <div>我是一个函数化组件</div>
            )
  }
//组件就是自定义标签
//调用组件
let com=<MyCom />
ReactDom.render(com,document.getElementById('root'))
//嵌套就是在一个组件里调用另一个组件

####  2、类组件
 class MyCom extends React.Component{
     render(){
         return (<div>类组件</div>)
     }
 }
```

##### 5、props

```js
//props是组件对外的接口，组件自己无法修改
#### 无状态组件
  function Com(props){
      return (
       <div>外部传递的数据:{props.text}</div>
      )
  }
  ReactDOM.render(<Com text="我是传递给Com组件的props数据" />,document.getElementById('root'))
  
  //传递多个参数，可使用对象传递
  let obj = {
      text:'props数据',
      num: 2,
  }
   ReactDOM.render(<Com {...obj} />,document.getElementById('root'))
  
  #### 类组件
  class MyCom extends React.Component{
     render(){
         return (<div>外部传递的数据：{this.props.text}---{this.props.num}</div>)
     }
 }
```

##### 6、props验证和默认值

[官网：类型验证](https://zh-hans.reactjs.org/docs/typechecking-with-proptypes.html#gatsby-focus-wrapper)

```js
#### 无状态组件
 function Com(props){
      return (
       <div>外部传递的数据:{props.text}</div>
      )
  }
  Com.defaultPros={
      text:'我是props中text的默认值'
  }
//如果是15x版本的react，纳闷我们使用||来完成
/*
   function Com(props){
      props.text = props.text||"我是默认值"
      return (
       <div>外部传递的数据:{props.text}</div>
      )
  }
*/

//props验证，验证传递进来的数据是否符合我们期望的类型或要求
//上线模式中要取消props验证
##### 方法
/*
1、引入props-types库 npm install --save prop-types
2、Com.propTypes = {
    text:PropTypes.number 验证text的数据类型必须是number类型
    num:PropTypes.number.isRequired     isRequired表示不能为空
}
*/

 ReactDOM.render(<Com {...obj} />,document.getElementById('root'))

### 类组件
class Title extends Component {
  // 使用类创建的组件，直接在这里写static方法，创建defaultProps
  static defaultProps = {
    name: 'React'
  }
  render () {
    return (
  		<h1>欢迎进入{this.props.name}的世界</h1>
  	)
  }
}
//使用类似无状态组件的方法设置默认值对类组件一样可以
```

### state基础

```js
//state是对内的接口，props是组件对外的接口
#### 申明式渲染     一切的数据改变操作都不需要我们操心，只要我们申明好数据，react会自动的对数据进行相应的改变
class Com extend React.Component{
    //在ES6中，不管子类写不写constructor new实例时都会补上constructor
    //如果我们写了constructor 之后就必须写上super()
    constructor(props){
        //如果在constructor中使用Props那么super必须写上props
        super(props);
        this.state={
            name:'嘻嘻'
        }
    }
    render(){
        return (
           <div>我是一个组件</div>
        )
    }
}
```

### state进阶

```js
//为了安全，标签插入时会转义成字符串，所以需要加dangerousSetInnerHTML={{__html:你要插入得内容}}

#### refa转发  (不能再无状态组件中使用 因为无状态组件没有实例)
//表示当前组件真正实例得引用 他会返回绑定当前属性得元素
//标识组件内部得元素 方便我们查找

//react给我们三种方式进行ref的使用
//1、字符串的方式
//2、回调函数(推荐)
//3、React cteateRef()(React16.3新增的一种方式)

##### 1、字符串的方式
class Com extend React.Component{
    fun()=>{
            console.log(this.refs.demoInput)
        }
    render(){
        return (
           <div>我是一个组件
            <input type='text' ref='demoInput' placeholder='请输入'>         <button onClick='{this.fun}'>点我得到输入框的值<>
            </div>
        )
    }
}

##### 2、回调函数(推荐)
//就是再dom节点上或者组件上挂载函数 函数的入参形参 是dom节点 达到的效果和字符串是一样的
class Com extend React.Component{
    fun()=>{
            console.log(this.textInput);
        }
    render(){
        return (
           <div>我是一个组件
            <input type='text' ref={(input)=>{this.textInput=input}} placeholder='请输入'>         <button onClick='{this.fun}'>点我得到输入框的值<>
            </div>
        )
    }
}

##### 3、createRef()
//就是在dom节点上或者组件上挂载函数 函数的入参形参 是dom节点 达到的效果和字符串是一样的
class Com extend React.Component{
    constructor(props){
        super(props);
        this.myRef=React.createRef();
    }
    fun()=>{
            console.log(this.myRef.current.value);
        }
    render(){
        return (
           <div>我是一个组件
            <input type='text' ref={this.myRef} placeholder='请输入'>         <button onClick='{this.fun}'>点我得到输入框的值<>
            </div>
        )
    }
}
```

#### 1、事件与this

```js
#### 修改this指向
//1、bind方式绑定
//2、函数通过箭头函数进行创建
//3、constructor中提前绑定
//4、将事件的调用写成箭头函数的调用方式

class Com extend React.Component{
    constructor{
        super();
        this.func=this.func.bind(this);
    }
   funa()=>{
            console.log(this);
        }
   funb=()=>{
            console.log(this);
        }
   func(){
       console.log(this);
   }
   fund(){
       console.log(this);
   }
    render(){
        return (
           <div>我是一个组件
           <button onClick='{this.funa.bind(this)}'>Bind方法</ button>              
            <button onClick='{this.funb}'>箭头函数</ button>                   <button onClick='{this.func}'>提前绑定</ button>
            <button onClick='{()=>{this.fund()}'>箭头函数的调用方式</ button>            
            </div>
        )
    }
}
```

#### 2、条件渲染

```js
### 条件渲染是什么 ---根据状态的变化只渲染其中的一部分
//1、if语句 jsx中不允许有if(这句话不知道怎么理解)
```

#### 3、状态提升

```js
// 多个组件需要反应相同的变化数据 ，提升到他们最近的一个父组件中
// 多个子组件需要利用对方状态的情况下 那么这个时候就需要使用到状态提升
class DemoA  extend React.Component{
    constructor(props){
        super(props);
    }
    render(){
        return (
           <div>我是第一个组件---{this.porps.text}
            </div>
        )
    }
}

class DemoB extend React.Component{
    constructor(props){
        super(props);
    }
    render(){
        return (
           <div>我是第二个组件---{this.porps.text}
            </div>
        )
    }
}

class Com extend React.Component{
    constructor(props){
        super(props);
        this.state={
            comtext:'我是两个人都想使用的数据'
        }
    }
    render(){
        return (
           <div>
            <DemoA text={this.state.comtext} />
            <DemoB text={this.state.comtext} />
            </div>
        )
    }
}
```

#### 4、creat-react-app的项目文件

```js
1、Public 静态资源文件
2、src 写代码的地方

//图片引用和vue一样，import或require或把图片放到Public
```

#### 5、组件传值

```js
//父传子 props
//子传父 利用函数形参传参
//同级传参 使用Pubsub-js插件

npm install --save pubsub-js
//import引用后在函数内使用下列语句即可
Pubsub.publish('事件',要传递的参数)
Pubsub.subscribe('事件',传递的参数)

//跨组件通信，react还提供了contextd api来实现
//理解：调用createContext方法返回一个对象，对象中的provider放置在一个足够高的节点，用来存储方法和状态，供其他所管辖的组件使用

#### 使用方法
//1、在一个足够高的节点使用解构出来的<Provider></Provider>
//2、在需要使用传值的地方，无状态组件使用
      <Consumer>
        {
          value => <div>{ value }</div>
        }
      </Consumer>,
//   类组件使用static contextType = testContent;其中testType是createContext()返回的对象，然后使用this.context调用provider的value值
```

#### 6、生命周期

[react生命周期表](https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/)

![old-lifecycle](D:\profession\html5\Stage_three\总结\react\old-lifecycle.PNG)

```js
#### 16.3版本做了一个大更新，16.4做了一个小更新，现在是16.14
//16.3废弃了很多生命周期，如果使用需要在前面加UNSAFE_
//16.4加长了getDrivedStateFromProps的范围
//类和模块内部默认就是严格模式，严格模式下老的生命周期直接报错

//getsnapshotBeforeUpdata做一个快照,返回值可以作为componentDidUpdata的参数
```



#### 7、插槽

```js
父组件：    <Child>插入内容</Child>
子组件：    <>{this.props.children}</>
```

#### 

