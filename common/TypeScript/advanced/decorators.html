<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>装饰器 | 微光的个人空间</title>
    <meta name="generator" content="VuePress 1.8.0">
    
    <meta name="description" content="此心光明，夫复何求">
    <meta name="keywords" content="前端，博客，微光">
    <meta name="author" content="微光">
    
    <link rel="preload" href="/docs/assets/css/0.styles.ec62b53c.css" as="style"><link rel="preload" href="/docs/assets/js/app.2c569677.js" as="script"><link rel="preload" href="/docs/assets/js/2.b553e760.js" as="script"><link rel="preload" href="/docs/assets/js/23.8effa93c.js" as="script"><link rel="prefetch" href="/docs/assets/js/10.27f358f4.js"><link rel="prefetch" href="/docs/assets/js/11.5e0534be.js"><link rel="prefetch" href="/docs/assets/js/12.a8e27388.js"><link rel="prefetch" href="/docs/assets/js/13.659b955f.js"><link rel="prefetch" href="/docs/assets/js/14.b50a1ddb.js"><link rel="prefetch" href="/docs/assets/js/15.60a6e67e.js"><link rel="prefetch" href="/docs/assets/js/16.39eb65dc.js"><link rel="prefetch" href="/docs/assets/js/17.9152cade.js"><link rel="prefetch" href="/docs/assets/js/18.2f507d00.js"><link rel="prefetch" href="/docs/assets/js/19.522a0124.js"><link rel="prefetch" href="/docs/assets/js/20.9f8f8ed1.js"><link rel="prefetch" href="/docs/assets/js/21.0f0c4298.js"><link rel="prefetch" href="/docs/assets/js/22.52f04b6c.js"><link rel="prefetch" href="/docs/assets/js/24.aa7e3823.js"><link rel="prefetch" href="/docs/assets/js/25.99fd944c.js"><link rel="prefetch" href="/docs/assets/js/26.2249d5eb.js"><link rel="prefetch" href="/docs/assets/js/27.faa0dfcc.js"><link rel="prefetch" href="/docs/assets/js/28.7967f478.js"><link rel="prefetch" href="/docs/assets/js/29.cb4d6ec0.js"><link rel="prefetch" href="/docs/assets/js/3.733d138c.js"><link rel="prefetch" href="/docs/assets/js/30.225a2b1f.js"><link rel="prefetch" href="/docs/assets/js/31.3e922dc0.js"><link rel="prefetch" href="/docs/assets/js/32.c3edfaba.js"><link rel="prefetch" href="/docs/assets/js/33.577309f7.js"><link rel="prefetch" href="/docs/assets/js/34.a33bb6f7.js"><link rel="prefetch" href="/docs/assets/js/35.4fb51e90.js"><link rel="prefetch" href="/docs/assets/js/36.d8148370.js"><link rel="prefetch" href="/docs/assets/js/37.6f38f7b2.js"><link rel="prefetch" href="/docs/assets/js/38.2ffc33cc.js"><link rel="prefetch" href="/docs/assets/js/39.4c392a9b.js"><link rel="prefetch" href="/docs/assets/js/4.26e91e99.js"><link rel="prefetch" href="/docs/assets/js/40.b9cd47c9.js"><link rel="prefetch" href="/docs/assets/js/41.f80814d7.js"><link rel="prefetch" href="/docs/assets/js/42.56088e8e.js"><link rel="prefetch" href="/docs/assets/js/43.eca173b9.js"><link rel="prefetch" href="/docs/assets/js/5.9c5ce922.js"><link rel="prefetch" href="/docs/assets/js/6.0fdbb52f.js"><link rel="prefetch" href="/docs/assets/js/7.351b5044.js"><link rel="prefetch" href="/docs/assets/js/8.c3bb1637.js"><link rel="prefetch" href="/docs/assets/js/9.1f4f5613.js">
    <link rel="stylesheet" href="/docs/assets/css/0.styles.ec62b53c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/docs/" class="home-link router-link-active"><!----> <span class="site-name">微光的个人空间</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/docs/common/" class="nav-link router-link-active">
  常见技术栈
</a></div><div class="nav-item"><a href="/docs/deepUse/" class="nav-link">
  深入理解
</a></div><div class="nav-item"><a href="/docs/tools/" class="nav-link">
  工具和扩展
</a></div><div class="nav-item"><a href="/docs/project/" class="nav-link">
  项目
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/docs/common/" class="nav-link router-link-active">
  常见技术栈
</a></div><div class="nav-item"><a href="/docs/deepUse/" class="nav-link">
  深入理解
</a></div><div class="nav-item"><a href="/docs/tools/" class="nav-link">
  工具和扩展
</a></div><div class="nav-item"><a href="/docs/project/" class="nav-link">
  项目
</a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>装饰器</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/docs/common/TypeScript/advanced/decorators.html#介绍" class="sidebar-link">介绍</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/docs/common/TypeScript/advanced/decorators.html#装饰器的种类" class="sidebar-link">装饰器的种类</a></li><li class="sidebar-sub-header"><a href="/docs/common/TypeScript/advanced/decorators.html#类的装饰器" class="sidebar-link">类的装饰器</a></li></ul></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="装饰器"><a href="#装饰器" class="header-anchor">#</a> 装饰器</h1> <h2 id="介绍"><a href="#介绍" class="header-anchor">#</a> 介绍</h2> <blockquote><p>装饰器是一种特殊类型的声明，它能够附加到类、类的函数、类属性、类函数的参数上，以达到修改类的行为。</p></blockquote> <h3 id="装饰器的种类"><a href="#装饰器的种类" class="header-anchor">#</a> 装饰器的种类</h3> <h4 id="根据装饰器的位置"><a href="#根据装饰器的位置" class="header-anchor">#</a> 根据装饰器的位置</h4> <ul><li>类装饰器</li> <li>类函数装饰器</li> <li>类属性装饰器</li> <li>类函数参数装饰器</li></ul> <h4 id="根据装饰器是否有参数"><a href="#根据装饰器是否有参数" class="header-anchor">#</a> 根据装饰器是否有参数</h4> <ul><li>无参装饰器(一般装饰器)</li> <li>有参装饰器(装饰器工厂)</li></ul> <h3 id="类的装饰器"><a href="#类的装饰器" class="header-anchor">#</a> 类的装饰器</h3> <ul><li>类装饰器的写法</li></ul> <div class="language- extra-class"><pre class="language-text"><code>function desc(target) {
  console.log(target) // 输出 [Function: Person]表示当前装饰的类
}

@desc
class Person {
  public name: string | undefined
  public age: number | 0

  constructor(name: string, age: number) {
    this.name = name
    this.age = age
  }
}
</code></pre></div><p>此处 target 类型会隐式定义为any, 这样会引发一个TS问题，解决方案：设置tsconfig.json</p> <p>1、&quot;noImplicitAny&quot;: false</p> <p>或者</p> <p>2、&quot;strict&quot;: false</p> <ul><li>使用类的装饰器扩展类的属性和方法
interface Class {
new(...args: any[]): {}
}</li></ul> <p>function desc<T extends="" Class="">(Target: T) {
console.log(Target)
return class extends Target {
gender = '男'
say() {
console.log(this.gender)
}
}
}</T></p> <p>@desc
class Person {
public name: string | undefined
public age: number | 0</p> <p>constructor(name, age) {
this.name = name
this.age = age
}</p> <p>say() {
console.log(this.name, this.age)
}
}</p> <p>let p = new Person('Felix', 20)
console.log(p)
p.say()</p> <div class="language- extra-class"><pre class="language-text"><code>
* 使用装饰器修改类的构造函数(构造函数的重载、方法重载)

</code></pre></div><p>function desc(target) {
return class extends target{
name = 'Felixlu'
age = 18
sayHell() {
console.log('我是重载后的', this.name)
}
}
}</p> <p>@desc
class Person {
public name: string | undefined
public age: number | 0</p> <p>constructor() {
this.name = 'Felix'
this.age = 20
}</p> <p>sayHell() {
console.log('hello word', this.name)
}
}</p> <p>let p = new Person()
console.log(p)
p.sayHell()</p> <div class="language- extra-class"><pre class="language-text"><code>
* 装饰器工厂的写法

</code></pre></div><p>function desc(params: string) {
return function (target: any) {
console.log('params', params)
console.log('target', target)
// 直接在原型上扩展一个属性
target.prototype.apiUrl = params
}
}</p> <p>@desc('好程序员')
class P {
say() {
console.log('说话')
}
}</p> <p>let p: any = new P()
console.log(p.apiUrl)</p> <div class="language- extra-class"><pre class="language-text"><code>
### 类函数装饰器

&gt; 它应用到方法上，可以用来监视、修改、替换该方法

* 基本使用

</code></pre></div><p>function desc(target, key, descriptor) {
console.log('target', target) // Person { say: [Function] } 表示类的原型
console.log('key', key) // 被装饰的函数名
console.log('descriptor', descriptor) // 被装饰的函数的对象属性
}</p> <p>class Person {
public name: string | undefined
public age: number | 0</p> <p>constructor(name, age) {
this.name = name
this.age = age
}</p> <p>@desc
say() {
console.log('说的方法')
}
}</p> <div class="language- extra-class"><pre class="language-text"><code>
* 在装饰器中添加类的原型属性和原型方法

</code></pre></div><p>function desc(target, key, descriptor) {
target.gender = '男'
target.foo = function () {
console.log('我是原型上的方法')
}
}</p> <p>class Person {
public name: string | undefined
public age: number | 0</p> <p>constructor(name, age) {
this.name = name
this.age = age
}</p> <p>@desc
say() {
console.log('说的方法')
}
}</p> <p>// 测试代码
let p: any = new Person('Felixlu', 20)
console.log(p)
console.log(Person.prototype)
p.say()
console.log(p.gender); // 使用p原型链上的属性
p.foo() // 调用了p原型链上的方法</p> <div class="language- extra-class"><pre class="language-text"><code>
* 使用装饰器拦截函数的调用（替换）

</code></pre></div><p>function desc(params: string) {
return function (target: any, key: string, descriptor: {[propsName: string]: any}) {
// 修改被装饰的函数
descriptor.value = function (...args: Array<any>) {
args = args.map(it =&gt; String(it))
console.log(args)
}
}
}</any></p> <p>class Person {
public name: string | undefined
public age: number | 0</p> <p>constructor(name, age) {
this.name = name
this.age = age
}</p> <p>@desc('装饰器上的参数')
say() {
console.log('说的方法')
}
}</p> <p>let p: any = new Person('Felixlu', 20)
console.log(p)
p.say(123, 23, '你好')</p> <div class="language- extra-class"><pre class="language-text"><code>
* 使用装饰器拦截函数的调用(附加新的功能)

</code></pre></div><p>function desc(params: string) {
return function (target: any, key: string, descriptor: {[propsName: string]: any}) {
// 修改被装饰的函数的
let method = descriptor.value
descriptor.value = function (...args: Array<any>) {
args = args.map(it =&gt; String(it))
console.log(args)
method.apply(this, args)
}
}
}
class Person {
public name: string | undefined
public age: number | 0</any></p> <p>constructor(name, age) {
this.name = name
this.age = age
}</p> <p>@desc('装饰器上的参数')
say(...args) {
console.log('说的方法', args)
}
}</p> <p>let p = new Person('Felixlu', 20)
console.log(p)
p.say(123, 23, '你好')</p> <div class="language- extra-class"><pre class="language-text"><code>
### 类属性装饰器

* 基本用法

</code></pre></div><p>function desc(target, name) {
console.log('target', target, target.constructor) // 表示类的原型
console.log('name', name) // 表示被装饰属性名
}</p> <p>class Person {
public name: string | undefined
public age: number | 0</p> <p>@desc
private gender: string | undefined</p> <p>constructor(name, age) {
this.name = name
this.age = age
}
}</p> <p>let p = new Person('Felixlu', 20)
console.log(p)</p> <div class="language- extra-class"><pre class="language-text"><code>
* 在装饰器中修改属性值

</code></pre></div><p>function desc(target, name) {
target[name] = '女'
}</p> <p>class Person {
public name: string | undefined
public age: number | 0</p> <p>@desc
public gender: string | undefined</p> <p>constructor(name, age) {
this.name = name
this.age = age
}</p> <p>say() {
console.log(this.name, this.age, this.gender)
}
}</p> <p>let p = new Person('Felixlu', 20)
console.log(p)
p.say()</p> <div class="language- extra-class"><pre class="language-text"><code>
* 类函数参数的装饰器

&gt; 参数装饰器表达式会在运行时候当做函数被调用，以使用参数装饰器为类的原型上附加一些元数据

* 基本用法

</code></pre></div><p>function desc(params: string) {
return function (target: any, key, index) {
console.log(target); // 类的原型
console.log(key); // 被装饰的名字
console.log(index); // 序列化
}
}
class Person {
public name: string | undefined
public age: number | 0</p> <p>constructor(name, age) {
this.name = name
this.age = age
}</p> <p>say(@desc('参数装饰器') age: number) {
console.log('说的方法')
}
}</p> <p>let p = new Person('Felixlu', 20)
console.log(p)
p.say(20)</p> <div class="language- extra-class"><pre class="language-text"><code>
* 为类的原型上添加一些东西

</code></pre></div><p>function desc(params: string) {
return function (target: any, key, index) {
console.log(target); // 类的原型
console.log(key); // 被装饰的名字
console.log(index); // 序列化
target.message = params;
}
}
class Person {
public name: string | undefined;
public age: number | 0;</p> <p>constructor(name, age) {
this.name = name;
this.age = age;
}</p> <p>say(@desc('参数装饰器') age: number) {
console.log('说的方法')
}
}</p> <p>let p: any = new Person('哈哈', 20);
console.log(p);
p.say(20);
console.log(p.message)</p> <div class="language- extra-class"><pre class="language-text"><code>
### 几种装饰器的执行顺序

</code></pre></div><p>function logCls(params: string) {
return function (target: any) {
console.log('4.类的装饰器');
}
}</p> <p>function logMethod(params: string) {
return function (target: any, key: string, descriptor: {[propsName: string]: any}) {
console.log('3.类的函数装饰器');
}
}</p> <p>function logParams(params: string) {
return function (target: any, name: string) {
console.log('1.类属性装饰器');
}
}</p> <p>function logQuery(params: string) {
return function (target: any, key: string, index: number) {
console.log('2.函数参数装饰器');
}
}</p> <p>@logCls('类的装饰器')
class Person{
@logParams('属性装饰器')
public name: string | undefined;</p> <p>@logMehod('函数装饰器')
getData(@logQuery('函数参数装饰器') age: number, @logQuery('函数参数装饰器') gender: string) {
console.log('----');
}
}</p> <div class="language- extra-class"><pre class="language-text"><code></code></pre></div></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">最后更新时间:</span> <span class="time">2021年2月2日星期二晚上9点49分</span></div></footer> <!----> </main></div><div class="global-ui"></div></div>
    <script src="/docs/assets/js/app.2c569677.js" defer></script><script src="/docs/assets/js/2.b553e760.js" defer></script><script src="/docs/assets/js/23.8effa93c.js" defer></script>
  </body>
</html>
